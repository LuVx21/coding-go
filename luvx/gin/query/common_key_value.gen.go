// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
    "context"

    "gorm.io/gorm"
    "gorm.io/gorm/clause"
    "gorm.io/gorm/schema"

    "gorm.io/gen"
    "gorm.io/gen/field"

    "gorm.io/plugin/dbresolver"

    "luvx/gin/model"
)

func newCommonKeyValue(db *gorm.DB, opts ...gen.DOOption) commonKeyValue {
    _commonKeyValue := commonKeyValue{}

    _commonKeyValue.commonKeyValueDo.UseDB(db, opts...)
    _commonKeyValue.commonKeyValueDo.UseModel(&model.CommonKeyValue{})

    tableName := _commonKeyValue.commonKeyValueDo.TableName()
    _commonKeyValue.ALL = field.NewAsterisk(tableName)
    _commonKeyValue.ID = field.NewInt64(tableName, "id")
    _commonKeyValue.BizType = field.NewInt32(tableName, "biz_type")
    _commonKeyValue.CommonKey = field.NewString(tableName, "common_key")
    _commonKeyValue.CommonValue = field.NewString(tableName, "common_value")
    _commonKeyValue.Invalid = field.NewInt32(tableName, "invalid")
    _commonKeyValue.CreateTime = field.NewInt64(tableName, "create_time")
    _commonKeyValue.UpdateTime = field.NewInt64(tableName, "update_time")

    _commonKeyValue.fillFieldMap()

    return _commonKeyValue
}

// commonKeyValue 通用kv结构
type commonKeyValue struct {
    commonKeyValueDo commonKeyValueDo

    ALL         field.Asterisk
    ID          field.Int64  // 自增id
    BizType     field.Int32  // 业务标识
    CommonKey   field.String // 键
    CommonValue field.String // 值
    Invalid     field.Int32  // 失效
    CreateTime  field.Int64  // 创建时间
    UpdateTime  field.Int64  // 修改时间

    fieldMap map[string]field.Expr
}

func (c commonKeyValue) Table(newTableName string) *commonKeyValue {
    c.commonKeyValueDo.UseTable(newTableName)
    return c.updateTableName(newTableName)
}

func (c commonKeyValue) As(alias string) *commonKeyValue {
    c.commonKeyValueDo.DO = *(c.commonKeyValueDo.As(alias).(*gen.DO))
    return c.updateTableName(alias)
}

func (c *commonKeyValue) updateTableName(table string) *commonKeyValue {
    c.ALL = field.NewAsterisk(table)
    c.ID = field.NewInt64(table, "id")
    c.BizType = field.NewInt32(table, "biz_type")
    c.CommonKey = field.NewString(table, "common_key")
    c.CommonValue = field.NewString(table, "common_value")
    c.Invalid = field.NewInt32(table, "invalid")
    c.CreateTime = field.NewInt64(table, "create_time")
    c.UpdateTime = field.NewInt64(table, "update_time")

    c.fillFieldMap()

    return c
}

func (c *commonKeyValue) WithContext(ctx context.Context) ICommonKeyValueDo {
    return c.commonKeyValueDo.WithContext(ctx)
}

func (c commonKeyValue) TableName() string { return c.commonKeyValueDo.TableName() }

func (c commonKeyValue) Alias() string { return c.commonKeyValueDo.Alias() }

func (c commonKeyValue) Columns(cols ...field.Expr) gen.Columns {
    return c.commonKeyValueDo.Columns(cols...)
}

func (c *commonKeyValue) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
    _f, ok := c.fieldMap[fieldName]
    if !ok || _f == nil {
        return nil, false
    }
    _oe, ok := _f.(field.OrderExpr)
    return _oe, ok
}

func (c *commonKeyValue) fillFieldMap() {
    c.fieldMap = make(map[string]field.Expr, 7)
    c.fieldMap["id"] = c.ID
    c.fieldMap["biz_type"] = c.BizType
    c.fieldMap["common_key"] = c.CommonKey
    c.fieldMap["common_value"] = c.CommonValue
    c.fieldMap["invalid"] = c.Invalid
    c.fieldMap["create_time"] = c.CreateTime
    c.fieldMap["update_time"] = c.UpdateTime
}

func (c commonKeyValue) clone(db *gorm.DB) commonKeyValue {
    c.commonKeyValueDo.ReplaceConnPool(db.Statement.ConnPool)
    return c
}

func (c commonKeyValue) replaceDB(db *gorm.DB) commonKeyValue {
    c.commonKeyValueDo.ReplaceDB(db)
    return c
}

type commonKeyValueDo struct{ gen.DO }

type ICommonKeyValueDo interface {
    gen.SubQuery
    Debug() ICommonKeyValueDo
    WithContext(ctx context.Context) ICommonKeyValueDo
    WithResult(fc func(tx gen.Dao)) gen.ResultInfo
    ReplaceDB(db *gorm.DB)
    ReadDB() ICommonKeyValueDo
    WriteDB() ICommonKeyValueDo
    As(alias string) gen.Dao
    Session(config *gorm.Session) ICommonKeyValueDo
    Columns(cols ...field.Expr) gen.Columns
    Clauses(conds ...clause.Expression) ICommonKeyValueDo
    Not(conds ...gen.Condition) ICommonKeyValueDo
    Or(conds ...gen.Condition) ICommonKeyValueDo
    Select(conds ...field.Expr) ICommonKeyValueDo
    Where(conds ...gen.Condition) ICommonKeyValueDo
    Order(conds ...field.Expr) ICommonKeyValueDo
    Distinct(cols ...field.Expr) ICommonKeyValueDo
    Omit(cols ...field.Expr) ICommonKeyValueDo
    Join(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo
    LeftJoin(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo
    RightJoin(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo
    Group(cols ...field.Expr) ICommonKeyValueDo
    Having(conds ...gen.Condition) ICommonKeyValueDo
    Limit(limit int) ICommonKeyValueDo
    Offset(offset int) ICommonKeyValueDo
    Count() (count int64, err error)
    Scopes(funcs ...func(gen.Dao) gen.Dao) ICommonKeyValueDo
    Unscoped() ICommonKeyValueDo
    Create(values ...*model.CommonKeyValue) error
    CreateInBatches(values []*model.CommonKeyValue, batchSize int) error
    Save(values ...*model.CommonKeyValue) error
    First() (*model.CommonKeyValue, error)
    Take() (*model.CommonKeyValue, error)
    Last() (*model.CommonKeyValue, error)
    Find() ([]*model.CommonKeyValue, error)
    FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommonKeyValue, err error)
    FindInBatches(result *[]*model.CommonKeyValue, batchSize int, fc func(tx gen.Dao, batch int) error) error
    Pluck(column field.Expr, dest interface{}) error
    Delete(...*model.CommonKeyValue) (info gen.ResultInfo, err error)
    Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
    UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
    Updates(value interface{}) (info gen.ResultInfo, err error)
    UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
    UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
    UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
    UpdateFrom(q gen.SubQuery) gen.Dao
    Attrs(attrs ...field.AssignExpr) ICommonKeyValueDo
    Assign(attrs ...field.AssignExpr) ICommonKeyValueDo
    Joins(fields ...field.RelationField) ICommonKeyValueDo
    Preload(fields ...field.RelationField) ICommonKeyValueDo
    FirstOrInit() (*model.CommonKeyValue, error)
    FirstOrCreate() (*model.CommonKeyValue, error)
    FindByPage(offset int, limit int) (result []*model.CommonKeyValue, count int64, err error)
    ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
    Scan(result interface{}) (err error)
    Returning(value interface{}, columns ...string) ICommonKeyValueDo
    UnderlyingDB() *gorm.DB
    schema.Tabler
}

func (c commonKeyValueDo) Debug() ICommonKeyValueDo {
    return c.withDO(c.DO.Debug())
}

func (c commonKeyValueDo) WithContext(ctx context.Context) ICommonKeyValueDo {
    return c.withDO(c.DO.WithContext(ctx))
}

func (c commonKeyValueDo) ReadDB() ICommonKeyValueDo {
    return c.Clauses(dbresolver.Read)
}

func (c commonKeyValueDo) WriteDB() ICommonKeyValueDo {
    return c.Clauses(dbresolver.Write)
}

func (c commonKeyValueDo) Session(config *gorm.Session) ICommonKeyValueDo {
    return c.withDO(c.DO.Session(config))
}

func (c commonKeyValueDo) Clauses(conds ...clause.Expression) ICommonKeyValueDo {
    return c.withDO(c.DO.Clauses(conds...))
}

func (c commonKeyValueDo) Returning(value interface{}, columns ...string) ICommonKeyValueDo {
    return c.withDO(c.DO.Returning(value, columns...))
}

func (c commonKeyValueDo) Not(conds ...gen.Condition) ICommonKeyValueDo {
    return c.withDO(c.DO.Not(conds...))
}

func (c commonKeyValueDo) Or(conds ...gen.Condition) ICommonKeyValueDo {
    return c.withDO(c.DO.Or(conds...))
}

func (c commonKeyValueDo) Select(conds ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Select(conds...))
}

func (c commonKeyValueDo) Where(conds ...gen.Condition) ICommonKeyValueDo {
    return c.withDO(c.DO.Where(conds...))
}

func (c commonKeyValueDo) Order(conds ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Order(conds...))
}

func (c commonKeyValueDo) Distinct(cols ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Distinct(cols...))
}

func (c commonKeyValueDo) Omit(cols ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Omit(cols...))
}

func (c commonKeyValueDo) Join(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Join(table, on...))
}

func (c commonKeyValueDo) LeftJoin(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.LeftJoin(table, on...))
}

func (c commonKeyValueDo) RightJoin(table schema.Tabler, on ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.RightJoin(table, on...))
}

func (c commonKeyValueDo) Group(cols ...field.Expr) ICommonKeyValueDo {
    return c.withDO(c.DO.Group(cols...))
}

func (c commonKeyValueDo) Having(conds ...gen.Condition) ICommonKeyValueDo {
    return c.withDO(c.DO.Having(conds...))
}

func (c commonKeyValueDo) Limit(limit int) ICommonKeyValueDo {
    return c.withDO(c.DO.Limit(limit))
}

func (c commonKeyValueDo) Offset(offset int) ICommonKeyValueDo {
    return c.withDO(c.DO.Offset(offset))
}

func (c commonKeyValueDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ICommonKeyValueDo {
    return c.withDO(c.DO.Scopes(funcs...))
}

func (c commonKeyValueDo) Unscoped() ICommonKeyValueDo {
    return c.withDO(c.DO.Unscoped())
}

func (c commonKeyValueDo) Create(values ...*model.CommonKeyValue) error {
    if len(values) == 0 {
        return nil
    }
    return c.DO.Create(values)
}

func (c commonKeyValueDo) CreateInBatches(values []*model.CommonKeyValue, batchSize int) error {
    return c.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (c commonKeyValueDo) Save(values ...*model.CommonKeyValue) error {
    if len(values) == 0 {
        return nil
    }
    return c.DO.Save(values)
}

func (c commonKeyValueDo) First() (*model.CommonKeyValue, error) {
    if result, err := c.DO.First(); err != nil {
        return nil, err
    } else {
        return result.(*model.CommonKeyValue), nil
    }
}

func (c commonKeyValueDo) Take() (*model.CommonKeyValue, error) {
    if result, err := c.DO.Take(); err != nil {
        return nil, err
    } else {
        return result.(*model.CommonKeyValue), nil
    }
}

func (c commonKeyValueDo) Last() (*model.CommonKeyValue, error) {
    if result, err := c.DO.Last(); err != nil {
        return nil, err
    } else {
        return result.(*model.CommonKeyValue), nil
    }
}

func (c commonKeyValueDo) Find() ([]*model.CommonKeyValue, error) {
    result, err := c.DO.Find()
    return result.([]*model.CommonKeyValue), err
}

func (c commonKeyValueDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.CommonKeyValue, err error) {
    buf := make([]*model.CommonKeyValue, 0, batchSize)
    err = c.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
        defer func() { results = append(results, buf...) }()
        return fc(tx, batch)
    })
    return results, err
}

func (c commonKeyValueDo) FindInBatches(result *[]*model.CommonKeyValue, batchSize int, fc func(tx gen.Dao, batch int) error) error {
    return c.DO.FindInBatches(result, batchSize, fc)
}

func (c commonKeyValueDo) Attrs(attrs ...field.AssignExpr) ICommonKeyValueDo {
    return c.withDO(c.DO.Attrs(attrs...))
}

func (c commonKeyValueDo) Assign(attrs ...field.AssignExpr) ICommonKeyValueDo {
    return c.withDO(c.DO.Assign(attrs...))
}

func (c commonKeyValueDo) Joins(fields ...field.RelationField) ICommonKeyValueDo {
    for _, _f := range fields {
        c = *c.withDO(c.DO.Joins(_f))
    }
    return &c
}

func (c commonKeyValueDo) Preload(fields ...field.RelationField) ICommonKeyValueDo {
    for _, _f := range fields {
        c = *c.withDO(c.DO.Preload(_f))
    }
    return &c
}

func (c commonKeyValueDo) FirstOrInit() (*model.CommonKeyValue, error) {
    if result, err := c.DO.FirstOrInit(); err != nil {
        return nil, err
    } else {
        return result.(*model.CommonKeyValue), nil
    }
}

func (c commonKeyValueDo) FirstOrCreate() (*model.CommonKeyValue, error) {
    if result, err := c.DO.FirstOrCreate(); err != nil {
        return nil, err
    } else {
        return result.(*model.CommonKeyValue), nil
    }
}

func (c commonKeyValueDo) FindByPage(offset int, limit int) (result []*model.CommonKeyValue, count int64, err error) {
    result, err = c.Offset(offset).Limit(limit).Find()
    if err != nil {
        return
    }

    if size := len(result); 0 < limit && 0 < size && size < limit {
        count = int64(size + offset)
        return
    }

    count, err = c.Offset(-1).Limit(-1).Count()
    return
}

func (c commonKeyValueDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
    count, err = c.Count()
    if err != nil {
        return
    }

    err = c.Offset(offset).Limit(limit).Scan(result)
    return
}

func (c commonKeyValueDo) Scan(result interface{}) (err error) {
    return c.DO.Scan(result)
}

func (c commonKeyValueDo) Delete(models ...*model.CommonKeyValue) (result gen.ResultInfo, err error) {
    return c.DO.Delete(models)
}

func (c *commonKeyValueDo) withDO(do gen.Dao) *commonKeyValueDo {
    c.DO = *do.(*gen.DO)
    return c
}
